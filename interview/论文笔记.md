## GraphReader

结论：

增强LLM的长文本能力有三种办法，一是训练，二是RAG检索增强式生成，三是本论文提的基于图的智能体，方法三效果最好；

GraphReader是一个创新的智能体系统，设计用于将长文本组织成图形结构。在探索过程中，系统利用预定义的函数和笔记本来促进规划和反思。

基于4k上下文窗口的GraphReader，在不同上下文长度的测试中，展示了可与GPT-4（具有128k上下文窗口）相媲美或超越的性能。

在四个具有挑战性的基准测试中，GraphReader在处理复杂的单跳和多跳问答任务时，表现出了卓越的性能。

GraphReader通过结构化长文本并利用智能体的自主探索，有效地提升了LLMs处理长上下文任务的能力，展示了在长文本理解方面的潜力。



摘要

长文本处理能力对于大语言模型（LLMs）来说至关重要，以便它们能够处理复杂和长输入的任务。尽管为了优化LLMs的长文本处理能力做出了许多努力，但在稳健地处理长输入方面仍然存在挑战。在本文中，我们介绍了GraphReader，这是一种基于图的智能体系统，通过将文本结构化为图并使用智能体自主探索这个图来处理长文本。收到问题后，智能体首先进行逐步分析并制定合理规划。然后，它调用一组预定义的函数来读取节点内容和邻居，从而促进从粗到细的图探索。在整个探索过程中，智能体不断记录新的见解并反思当前情况，以优化过程，直到它收集到足够的信息来生成答案。在LV-Eval数据集上的实验结果表明，使用4k上下文窗口的GraphReader，在从16k到256k的上下文长度上，始终以较大优势超越GPT-4-128k。此外，我们的方法在四个具有挑战性的单跳和多跳基准测试上表现出更优越的性能。

1 引言

大语言模型（LLMs）在自然语言理解和生成方面取得了巨大进步（Zhao等人，2023）。然而，基于transformer的LLMs在处理长文本方面仍然存在困难，这是由于上下文窗口和内存使用的限制。目前解决LLMs长文本任务的技术可以分为两个视角：1）模型级别，包括使用修改过的位置嵌入进行微调（Chen等人，2023b；Zhu等人，2023；Peng等人，2023；Ding等人，2024），以及应用具有修改过的注意力机制的transformer变体（Dai等人，2019；Munkhdalai等人，2024；Gu和Dao，2023）；2）智能体级别，即，使用检索增强的LLM或智能体来处理长文本，使用有限上下文窗口的LLM（Nakano等人，2021；Lee等人，2024）。

然而，模型级别方法通常使用目标长度文本训练LLMs，这在构建训练数据集和产生高昂训练成本方面带来了挑战（Zhu等人，2023）。此外，使用这些方法优化的长文本LLMs倾向于忽略长文本中的关键细节，这是众所周知的“中间丢失”（Liu等人，2024），限制了它们处理复杂任务的能力，例如多跳问题。智能体级别的方法将输入文本转换为树（Chen等人，2023a）或分页页面（Lee等人，2024），未能捕捉到多跳和长距离依赖关系，因此限制了它们在非常长文本上的有效性，如图1所示。


为解决这些问题，我们提出了一个名为GraphReader的基于图的智能体。如图2所示，GraphReader首先将长文本分割成离散的块，提取关键信息，并将这些信息压缩成关键元素和原子事实。然后，这些关键元素和事实被用来构建一个图，其中节点代表关键元素及其相关的原子事实。这种图结构有效地捕捉了长文本中的长距离依赖和多跳关系。随后，GraphReader使用预定义的函数自主探索这个图，按照逐步合理的计划进行指导。

基于给定的问题，智能体逐步从粗略的关键元素和原子事实访问到详细的原始文本块，做笔记并反思，直到它收集到足够的信息来生成答案。总结来说，我们的主要贡献有三个方面：

我们引入了GraphReader，这是一个新颖的智能体系统，旨在将长文本组织成图结构，利用预定义的函数和笔记本，在探索过程中促进规划和反思。

GraphReader建立了一个可扩展的长文本能力，基于4k上下文窗口，展示了与具有128k上下文窗口的GPT-4相当或超越的性能，跨越不同的上下文长度。

在四个具有挑战性的基准测试上进行的广泛实验表明，GraphReader在复杂的单跳和多跳问答任务中取得了优越的性能。



2 相关工作

长文本LLMs 最近的努力（Chen等人，2023b；Ding等人，2024；Peng等人，2023）集中在位置插值（PI）上，以增强长文本能力。然而，这些方法需要在全文上进行训练，导致数据和训练成本显著增加（Chen等人，2023c；Fu等人，2024；Bai等人，2024b）。因此，PoSE（Zhu等人，2023）和SkipAlign（Wu等人，2024a）研究了数据跳过策略，但倾向于忽略长文本中的详细信息（Liu等人，2024；Bai等人，2024a；Wu等人，2024b）。

此外，尽管上下文窗口扩展得多么广泛，它仍然受到预定义固定长度的限制。为解决这些限制，提出了具有修改过的注意力机制的transformer变体（Dai等人，2019；Gu和Dao，2023；Munkhdalai等人，2024）。然而，这些模型容易丢失早期信息。

检索ARG 检索增强生成（RAG）利用广泛的文档数据库提取与任务相关的信息，以帮助响应生成。许多努力调查了不同级别的检索粒度，包括标记（Khandelwal等人，2019）、实体（Févry等人，2020；De Jong等人，2021）和块（Liu，2024；LangChain-team，2024）。其他方法探索了不同的检索方法，如BM25（Rasooli和Tetreault，2015）和基于学习的策略（Khattab和Zaharia，2020；Sachan等人，2023；Sun等人，2021）。

尽管RAG具有能力，但在解决复杂问题时面临挑战，因为难以开发强大的决策机制。相比之下，我们使用的智能体使用规划和反思来收集必要信息，有效地解决复杂问题。

检索智能体 最近的工作越来越多地利用LLMs作为智能体来解决复杂问题，利用它们强大的规划和反思能力（Yao等人，2022；Park等人，2023）。这些能力已应用于复杂任务，如函数调用（Li等人，2023）和知识图谱问答（KGQA）（Sun等人，2023；Luo等人，2023）。智能体还能够检索非结构化信息。例如，WebGPT（Nakano等人，2021）模拟人类行为在互联网上搜索特定答案。此外，MemWalker（Chen等人，2023a）和PEARL（Sarthi等人，2024）将文档组织成树结构，而ReadAgent（Lee等人，2024）将文档压缩成要点记忆目录。然而，这些方法通常难以应对多跳问题。KGP（Wang等人，2024）将文档组织成图，但它主要使用智能体生成查询，因此没有充分利用智能体的规划和反思能力。

3 方法

3.1 预备知识

GraphReader建立在图G = {V, E}上，其中每个节点vi ∈ V包含一个关键元素ki和一组摘要内容，即原子事实Ai。换句话说，vi = {ki, Ai}。并且每条边eij ∈ E代表节点vi和vj之间的关系。这种图结构使GraphReader能够在有限的上下文窗口内捕捉输入文档D的全局信息，允许它决定是详细探索当前节点还是跳转到相邻节点。在图探索期间，GraphReader收集支持事实，并在收集到足够信息回答问题后终止探索。如图2所示，GraphReader的整个过程包括以下三个阶段：图构建、图探索和答案推理。这三个阶段使用的提示详见附录A，我们过程的详细示例可以在附录H中找到。

3.2 图构建

为了在LLM的上下文限制内从文档D中提取节点，我们首先将D分割成长度为L的块，同时保留段落结构。对于每个块，我们提示LLM将其摘要成原子事实，这是简化原始文本的最小不可分割事实。我们还提示LLM从每个原子事实中提取关键元素，如基本名词、动词和形容词。处理完所有块后，我们根据Lu等人（2023）的描述规范化关键元素，以处理词汇噪声和粒度问题，创建最终的关键元素集。然后我们构建每个节点vi = (ki, Ai)，其中ki是关键元素，Ai是对应于ki的原子事实集。

最后，如果关键元素ki出现在Aj中，反之亦然，我们就将两个节点vi和vj链接起来。

3.3 图形探索

3.3.1 智能体初始化

给定一个图形G和一个疑问Q，我们的目标是设计一个能够使用预定义函数自主探索图形的智能体。智能体首先通过维护一个笔记本来记录支持性事实，这些事实最终被用来推导出最终答案。然后，智能体执行两个关键初始化：定义合理规划和选择初始节点。

合理规划 为了解决复杂的现实世界多跳问题，预先规划解决方案至关重要。智能体逐步分解原始问题，识别所需的关键信息，并形成一个合理规划。初始节点 选择策略性的起始点对于提高搜索效率至关重要。智能体评估所有节点V的关键元素，并根据问题和合理规划选择N个初始节点。

3.3.2 探索

在选择了N个初始节点作为起始点后，智能体通过首先探索原子事实，然后探索节点的块来探索每个初始节点。接下来，它根据问题和合理规划探索邻近节点。在探索过程中，智能体不断更新笔记本中的相关信息。

探索原子事实 将与节点相关的所有原始文本块包含在上下文窗口内是不切实际的。因此，智能体采用从粗到细的策略，从阅读原子事实到原始文本，因为所有原子事实都可以适应上下文窗口。最初，与节点相关的所有原子事实按其对应的块分组，用相应的块ID标记，并提供给智能体。这允许智能体通过阅读所有原子事实组来捕捉每个块的概览。同时，智能体利用问题、合理规划和笔记本中的笔记来反思所需的线索，并确定哪个块可能包含有用信息。随后，智能体被提供了两个函数：

read_chunk，如果智能体确定某些块对进一步阅读有价值，它将用块ID完成函数参数，即read_chunk(List[ID])，并将这些ID添加到块队列中。

stop_and_read_neighbor，相反，如果智能体认为没有块值得进一步阅读，它将完成阅读此节点并继续探索邻近节点。

探索块 当块队列非空时，表示智能体已经识别出多个感兴趣的文本块。然后我们遍历队列，阅读每个块。这一步是必要的，因为原子事实仅总结关键信息并提供简短的线索，而具体细节最好直接从原始文本块中获得。在阅读块时，智能体将再次考虑问题和计划，思考可以添加到当前笔记本中的信息。在笔记本中发现的任何支持性事实都将被记录下来。根据更新后的笔记本，智能体将选择以下四个函数之一：

search_more，如果支持性事实不足，智能体将继续探索队列中的块；

read_previous_chunk和3)read_subsequent_chunk，由于截断问题，相邻块可能包含相关和有用的信息，智能体可以将这些ID插入队列；

终止，如果已收集到足够的信息以回答问题，智能体将完成探索。

探索邻居 一旦当前节点的原子事实和块队列已完全处理，表明该节点已被彻底探索，智能体需要访问下一个节点。考虑到问题、合理规划和笔记本的内容，智能体检查所有邻近节点，即关键元素，并执行以下两个函数之一：

read_neighbor_node，智能体选择一个可能有助于回答问题的邻近节点，并重新进入探索原子事实和块的过程；

终止，智能体确定所有邻近节点都不包含有用信息，它完成探索。



3.4 答案推理

在N个智能体独立收集信息并停止探索后，我们将编译每个智能体的所有笔记进行推理并生成最终答案。使用思维链（Wei等人，2022），LLM首先通过考虑来自其他记忆的补充信息，并使用多数投票策略来解决任何不一致性，来分析每个笔记。

最终，LLM将考虑所有可用信息以生成最终答案。

4 实验

4.1 实验设置

评估基准 我们在两种类型的长上下文QA基准上进行实验，包括多跳长上下文QA，即HotpotQA（Yang等人，2018），2WikiMultihopQA（Ho等人，2020），MuSiQue（Trivedi等人，2022），以及一个单跳长上下文QA基准，即NarrativeQA（Kociský等人，2018）来自LongBench（Bai等人，2023）。此外，我们还包括了LVEval（Yuan等人，2024）中的HotpotWikiQA-mixup，这是一个具有五个文本长度级别的多跳基准：16k、32k、64k、128k和256k。表1提供了这些基准的统计信息，详细信息在附录C中提供。

评估指标 我们使用几种自动评估指标，即F1分数、精确匹配（EM）分数，以及LV-Eval（Yuan等人，2024）引入的优化F1*分数。具体来说，F1*首先计算金色答案关键词的召回率，并且只有在超过某个阈值时才计算F1分数。否则，分数默认为零。尽管自动指标具有成本效益，但其准确性可能会受到响应格式的影响。因此，我们使用LLM评估答案正确性，使用LLM表示为LLM-Rating-1（LR-1）和LLM-Rating-2（LR-2），遵循ReadAgent（Lee等人，2024）。评估指标的详细信息可以在附录B中找到。

基线方法 我们将我们的方法与以下基线方法进行比较：检索增强生成（RAG）、长上下文LLM和基于智能体的方法。（1）RAG：我们选择Okapi BM25（Robertson和Zaragoza，2009）或OpenAI API嵌入模型Ada-002检索与问题最相关的块，并使用GPT-4-128k（gpt-4-1106-preview）读取检索到的块并回答问题。（2）长上下文LLM：我们选择GPT-4-128k直接阅读全文，当文本内容适合输入窗口时，或将文本分割成块进行顺序阅读。（3）基于智能体的方法：我们选择ReadAgent（Lee等人，2024），它使用基于智能体的系统执行检索和阅读过程，用于长上下文QA。这些方法的详细描述在附录D中提供。

实现细节 在我们的实验中，我们使用GPT-4-128k作为我们的方法和基线方法，将温度设置为0.2。对于GraphReader，输入窗口大小配置为4k令牌，除非另有说明。我们将最大块大小限制为2k令牌，从5个初始节点开始搜索，并为每个搜索路径设置10个函数调用限制。

图片

4.2 主要结果

图片

图片

表2和表3展示了三种类型的方法在四个多跳长上下文基准和一个单跳长上下文基准上的结果。基于这些结果，我们有以下发现：

RAG方法的结果 如表2所示，基于BM25和Ada002的RAG方法在与长上下文LLM和基于智能体的方法相比时表现最差。可能的原因是文本检索难以回忆起包含回答输入问题所需支持事实的所有块。尽管增加检索到的块的数量可以提高文本检索的性能，但上下文窗口将限制这些RAG方法的有效性。

长上下文LLM的结果 从表2中的结果可以看出，使用GPT-4-128k直接回答长上下文问题在性能上显著优于RAG方法，甚至在三个长上下文基准上超过了ReadAgent。这是因为GPT-4-128k在处理长文本和执行多跳推理任务方面的优越性能。此外，这四个基准的长度明显短于128k上下文窗口，从而减轻了“中间迷失”对模型性能的影响。

基于智能体的方法的结果 通过比较表2中我们的方法与所有基线，很明显我们的方法在四个长上下文基准上始终优于它们，并在多跳长上下文任务中展现了卓越的性能。在我们的方法中，得益于图形能够捕捉详细信息之间的关系，我们的方法可以高效地识别关键信息并搜索输入问题的支持事实。这一策略显著增强了智能体在多跳推理和捕捉长上下文中关键信息的长距离依赖方面的能力。此外，表2中的结果表明，具有128k上下文窗口设置的ReadAgent在性能上不如具有4k上下文窗口的GraphReader，甚至比GPT-4-128k全文阅读还要差。我们认为这是由于ReadAgent过度压缩原始文本到要点记忆中，并将所有混合记忆提供给模型进行页码选择的策略。与我们的GraphReader相比，ReadAgent的策略可能限制了智能体识别具体细节和捕捉长上下文中关键元素之间的内在联系的能力，从而影响了其整体性能。这进一步表明我们的方法可以更有效地解锁受限上下文窗口LLM在处理长上下文方面的能力。此外，我们观察到我们方法的性能与直接向LLM提供支持事实（即表2中的Golden）所取得的性能非常接近。这是因为我们的方法不仅包括预先规划、反思和各种行动，还包括使用包含关键信息的图形，促进智能体搜索正确的支持事实。

图片

在极长上下文任务上的评估

如之前的实验所示，它证明了使用有限上下文窗口LLM与我们的GraphReader一起处理长上下文任务的有效性。在这里，我们想研究极长上下文对我们的GraphReader的影响。如表3所示，与所有基线相比，我们的GraphReader不仅在从16k到256k令牌的文本长度范围内始终优于这些方法，而且还随着上下文长度的扩展表现出鲁棒性。这表明我们的方法通过使用有限上下文窗口LLM的图形探索仍然有效处理极长文本。随着输入上下文长度的增加，GPT-4-128k全文阅读的性能逐渐下降。相比之下，我们的方法在16k上下文长度下相对于GPT-4-128k全文阅读在LR-1上实现了10.53%的性能提升。当上下文长度增加到128k时，我们的方法相对于GPT-4-128k实现了75.00%的性能提升。这可以归因于随着上下文长度的增加，"中间迷失"效应对GPT-4-128k的影响变得越来越严重。其次，我们观察到ReadAgent在处理极长上下文方面显著落后于我们的方法。这是因为缺乏关于每个页面内容的详细信息可以使ReadAgent的页面选择变得非常困难，特别是在处理极长上下文时。这进一步证明了我们的方法可以通过探索包含细粒度信息的图形有效解决使用有限上下文窗口LLM处理极长上下文的挑战。

图片

4.3 消融研究

合理规划的效果 在图形探索阶段，我们引入了一个合理规划来帮助智能体逐步分析复杂的输入问题，并引导智能体探索图形。为了验证合理规划的有效性，我们在智能体初始化期间移除了它，并在四个长上下文问答基准上进行了实验。

图片

表4显示，合理规划在指导智能体在图形中的节点选择和探索方面是有效的。

节点选择的效果 我们进行了随机选择初始节点和邻近节点的实验，以证明我们的系统在根据所需信息的推理选择访问哪些节点方面的必要性。正如表4所示，随机选择导致显著的性能下降，平均下降了18%。

这表明GraphReader仔细考虑了节点选择，从而实现了更合理和有效的探索。

初始节点数量的影响 我们在多跳和单跳问答数据集上进行了不同初始节点数量的实验，以评估初始节点数量对GraphReader性能的影响。结果显示在图3中。增加节点数量在一定程度上可以提高性能，最佳性能在5个初始节点时达到，我们将其设置为默认值。然而，超过这个阈值后，性能会下降，特别是在单跳场景中，可能是由于太多初始节点带来的噪音。

块大小的影响 我们研究了块大小L对GraphReader性能的影响。如图4所示，当L=2k时实现了最佳性能。当L超过某个阈值时，性能会下降，因为较大的块会导致模型忽略重要细节。相反，较小的块会导致更多的语义截断，妨碍理解和准确提取原子事实。因此，我们选择L=2k作为默认块大小。

4.4 进一步分析

图片

成本分析 为了评估我们方法的推理成本，我们比较了ReadAgent和GraphReader在每个问题上的平均令牌消耗。如表5所示，GraphReader仅比ReadAgent多使用了1.08倍的令牌，但实现了超过两倍的性能提升，展现了其优越性。此外，在第一轮文档预处理后，后续探索中的令牌消耗显著减少，远低于原始数据集的令牌计数。

召回率分析 为了评估我们方法在关键信息召回方面的优势，我们使用GPT-4来评估HotpotWikiQA-mixup数据集上支持事实的召回。如图5所示，无论输入长度如何，我们的模型始终优于其他基线方法。

图片

随着上下文长度从16k增加到256k，所有方法的支持事实召回率都有所下降。然而，GraphReader在256k上下文长度下保持了约60%的召回率，与ReadAgent的显著下降形成对比。这证明了GraphReader在处理长上下文方面的可扩展性和有效性。更多细节和评估提示可以在附录E中找到。

为了进一步展示GraphReader在不同粒度上的召回率，我们使用相同的方法分别计算了支持事实和样本粒度的召回率，详细方法见附录E。支持事实的粒度指的是整个数据集中所有支持事实的召回率。至于样本粒度，只有当一个样本的所有支持事实都被召回时，该样本才被视为被召回。如表6所示，最终笔记本的召回率略高于原子事实的召回率，这表明我们的方法能够在探索过程中从块中提取更多有效的信息，间接反映了其探索的智能性和有效性。

5 结论

本文介绍了GraphReader，这是一个基于图形的智能体，旨在增强大型语言模型的长上下文能力。GraphReader将长文本组织成图形结构，并使用自主智能体来探索图形，成功地在相对较小的4k上下文窗口内建立了长距离依赖。实验表明，GraphReader在各种长上下文单跳和多跳问答基准上的性能超过了具有128k输入长度的GPT-4。

6 局限性

首先，GraphReader是使用现成的GPT-4 API构建的。由于它是闭源的，可能存在潜在的限制，如每秒查询次数(QPS)的限制和地区限制。

因此，未来的工作将涉及收集数据、训练模型，并使它们开源，以贡献给更广泛的社区。其次，智能体的效率取决于其规划和推理能力。未来的研究也将探索这些特性的增强，以提高我们方法的有效性。












